// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: vrs.proto
#ifndef GRPC_vrs_2eproto__INCLUDED
#define GRPC_vrs_2eproto__INCLUDED

#include "vrs.pb.h"

#include <grpcpp/impl/codegen/async_stream.h>
#include <grpcpp/impl/codegen/async_unary_call.h>
#include <grpcpp/impl/codegen/method_handler_impl.h>
#include <grpcpp/impl/codegen/proto_utils.h>
#include <grpcpp/impl/codegen/rpc_method.h>
#include <grpcpp/impl/codegen/service_type.h>
#include <grpcpp/impl/codegen/status.h>
#include <grpcpp/impl/codegen/stub_options.h>
#include <grpcpp/impl/codegen/sync_stream.h>

namespace grpc {
class CompletionQueue;
class Channel;
class ServerCompletionQueue;
class ServerContext;
}  // namespace grpc

namespace vrs {
namespace rpc {

class VrsRpc final {
 public:
  static constexpr char const* service_full_name() {
    return "vrs.rpc.VrsRpc";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    // 根据路径进行检索，并给出评分
    std::unique_ptr< ::grpc::ClientReaderInterface< ::vrs::rpc::SearchResult>> Search(::grpc::ClientContext* context, const ::vrs::rpc::SearchRequest& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::vrs::rpc::SearchResult>>(SearchRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::vrs::rpc::SearchResult>> AsyncSearch(::grpc::ClientContext* context, const ::vrs::rpc::SearchRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::vrs::rpc::SearchResult>>(AsyncSearchRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::vrs::rpc::SearchResult>> PrepareAsyncSearch(::grpc::ClientContext* context, const ::vrs::rpc::SearchRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::vrs::rpc::SearchResult>>(PrepareAsyncSearchRaw(context, request, cq));
    }
    // 视频处理请求
    virtual ::grpc::Status ProcessVideo(::grpc::ClientContext* context, const ::vrs::rpc::ProcessVideoRequest& request, ::vrs::rpc::Result* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::vrs::rpc::Result>> AsyncProcessVideo(::grpc::ClientContext* context, const ::vrs::rpc::ProcessVideoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::vrs::rpc::Result>>(AsyncProcessVideoRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::vrs::rpc::Result>> PrepareAsyncProcessVideo(::grpc::ClientContext* context, const ::vrs::rpc::ProcessVideoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::vrs::rpc::Result>>(PrepareAsyncProcessVideoRaw(context, request, cq));
    }
    // 合并各个视频的索引为全局索引
    virtual ::grpc::Status Merge(::grpc::ClientContext* context, const ::vrs::rpc::Empty& request, ::vrs::rpc::Result* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::vrs::rpc::Result>> AsyncMerge(::grpc::ClientContext* context, const ::vrs::rpc::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::vrs::rpc::Result>>(AsyncMergeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::vrs::rpc::Result>> PrepareAsyncMerge(::grpc::ClientContext* context, const ::vrs::rpc::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::vrs::rpc::Result>>(PrepareAsyncMergeRaw(context, request, cq));
    }
  private:
    virtual ::grpc::ClientReaderInterface< ::vrs::rpc::SearchResult>* SearchRaw(::grpc::ClientContext* context, const ::vrs::rpc::SearchRequest& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::vrs::rpc::SearchResult>* AsyncSearchRaw(::grpc::ClientContext* context, const ::vrs::rpc::SearchRequest& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::vrs::rpc::SearchResult>* PrepareAsyncSearchRaw(::grpc::ClientContext* context, const ::vrs::rpc::SearchRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::vrs::rpc::Result>* AsyncProcessVideoRaw(::grpc::ClientContext* context, const ::vrs::rpc::ProcessVideoRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::vrs::rpc::Result>* PrepareAsyncProcessVideoRaw(::grpc::ClientContext* context, const ::vrs::rpc::ProcessVideoRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::vrs::rpc::Result>* AsyncMergeRaw(::grpc::ClientContext* context, const ::vrs::rpc::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::vrs::rpc::Result>* PrepareAsyncMergeRaw(::grpc::ClientContext* context, const ::vrs::rpc::Empty& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel);
    std::unique_ptr< ::grpc::ClientReader< ::vrs::rpc::SearchResult>> Search(::grpc::ClientContext* context, const ::vrs::rpc::SearchRequest& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::vrs::rpc::SearchResult>>(SearchRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::vrs::rpc::SearchResult>> AsyncSearch(::grpc::ClientContext* context, const ::vrs::rpc::SearchRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::vrs::rpc::SearchResult>>(AsyncSearchRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::vrs::rpc::SearchResult>> PrepareAsyncSearch(::grpc::ClientContext* context, const ::vrs::rpc::SearchRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::vrs::rpc::SearchResult>>(PrepareAsyncSearchRaw(context, request, cq));
    }
    ::grpc::Status ProcessVideo(::grpc::ClientContext* context, const ::vrs::rpc::ProcessVideoRequest& request, ::vrs::rpc::Result* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::vrs::rpc::Result>> AsyncProcessVideo(::grpc::ClientContext* context, const ::vrs::rpc::ProcessVideoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::vrs::rpc::Result>>(AsyncProcessVideoRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::vrs::rpc::Result>> PrepareAsyncProcessVideo(::grpc::ClientContext* context, const ::vrs::rpc::ProcessVideoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::vrs::rpc::Result>>(PrepareAsyncProcessVideoRaw(context, request, cq));
    }
    ::grpc::Status Merge(::grpc::ClientContext* context, const ::vrs::rpc::Empty& request, ::vrs::rpc::Result* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::vrs::rpc::Result>> AsyncMerge(::grpc::ClientContext* context, const ::vrs::rpc::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::vrs::rpc::Result>>(AsyncMergeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::vrs::rpc::Result>> PrepareAsyncMerge(::grpc::ClientContext* context, const ::vrs::rpc::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::vrs::rpc::Result>>(PrepareAsyncMergeRaw(context, request, cq));
    }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    ::grpc::ClientReader< ::vrs::rpc::SearchResult>* SearchRaw(::grpc::ClientContext* context, const ::vrs::rpc::SearchRequest& request) override;
    ::grpc::ClientAsyncReader< ::vrs::rpc::SearchResult>* AsyncSearchRaw(::grpc::ClientContext* context, const ::vrs::rpc::SearchRequest& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::vrs::rpc::SearchResult>* PrepareAsyncSearchRaw(::grpc::ClientContext* context, const ::vrs::rpc::SearchRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::vrs::rpc::Result>* AsyncProcessVideoRaw(::grpc::ClientContext* context, const ::vrs::rpc::ProcessVideoRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::vrs::rpc::Result>* PrepareAsyncProcessVideoRaw(::grpc::ClientContext* context, const ::vrs::rpc::ProcessVideoRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::vrs::rpc::Result>* AsyncMergeRaw(::grpc::ClientContext* context, const ::vrs::rpc::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::vrs::rpc::Result>* PrepareAsyncMergeRaw(::grpc::ClientContext* context, const ::vrs::rpc::Empty& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_Search_;
    const ::grpc::internal::RpcMethod rpcmethod_ProcessVideo_;
    const ::grpc::internal::RpcMethod rpcmethod_Merge_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    // 根据路径进行检索，并给出评分
    virtual ::grpc::Status Search(::grpc::ServerContext* context, const ::vrs::rpc::SearchRequest* request, ::grpc::ServerWriter< ::vrs::rpc::SearchResult>* writer);
    // 视频处理请求
    virtual ::grpc::Status ProcessVideo(::grpc::ServerContext* context, const ::vrs::rpc::ProcessVideoRequest* request, ::vrs::rpc::Result* response);
    // 合并各个视频的索引为全局索引
    virtual ::grpc::Status Merge(::grpc::ServerContext* context, const ::vrs::rpc::Empty* request, ::vrs::rpc::Result* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_Search : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_Search() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_Search() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Search(::grpc::ServerContext* context, const ::vrs::rpc::SearchRequest* request, ::grpc::ServerWriter< ::vrs::rpc::SearchResult>* writer) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSearch(::grpc::ServerContext* context, ::vrs::rpc::SearchRequest* request, ::grpc::ServerAsyncWriter< ::vrs::rpc::SearchResult>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(0, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ProcessVideo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_ProcessVideo() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_ProcessVideo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ProcessVideo(::grpc::ServerContext* context, const ::vrs::rpc::ProcessVideoRequest* request, ::vrs::rpc::Result* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestProcessVideo(::grpc::ServerContext* context, ::vrs::rpc::ProcessVideoRequest* request, ::grpc::ServerAsyncResponseWriter< ::vrs::rpc::Result>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Merge : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_Merge() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_Merge() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Merge(::grpc::ServerContext* context, const ::vrs::rpc::Empty* request, ::vrs::rpc::Result* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestMerge(::grpc::ServerContext* context, ::vrs::rpc::Empty* request, ::grpc::ServerAsyncResponseWriter< ::vrs::rpc::Result>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_Search<WithAsyncMethod_ProcessVideo<WithAsyncMethod_Merge<Service > > > AsyncService;
  template <class BaseClass>
  class WithGenericMethod_Search : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_Search() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_Search() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Search(::grpc::ServerContext* context, const ::vrs::rpc::SearchRequest* request, ::grpc::ServerWriter< ::vrs::rpc::SearchResult>* writer) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ProcessVideo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_ProcessVideo() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_ProcessVideo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ProcessVideo(::grpc::ServerContext* context, const ::vrs::rpc::ProcessVideoRequest* request, ::vrs::rpc::Result* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Merge : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_Merge() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_Merge() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Merge(::grpc::ServerContext* context, const ::vrs::rpc::Empty* request, ::vrs::rpc::Result* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ProcessVideo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_ProcessVideo() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler< ::vrs::rpc::ProcessVideoRequest, ::vrs::rpc::Result>(std::bind(&WithStreamedUnaryMethod_ProcessVideo<BaseClass>::StreamedProcessVideo, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_ProcessVideo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ProcessVideo(::grpc::ServerContext* context, const ::vrs::rpc::ProcessVideoRequest* request, ::vrs::rpc::Result* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedProcessVideo(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::vrs::rpc::ProcessVideoRequest,::vrs::rpc::Result>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Merge : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_Merge() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler< ::vrs::rpc::Empty, ::vrs::rpc::Result>(std::bind(&WithStreamedUnaryMethod_Merge<BaseClass>::StreamedMerge, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_Merge() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Merge(::grpc::ServerContext* context, const ::vrs::rpc::Empty* request, ::vrs::rpc::Result* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedMerge(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::vrs::rpc::Empty,::vrs::rpc::Result>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_ProcessVideo<WithStreamedUnaryMethod_Merge<Service > > StreamedUnaryService;
  template <class BaseClass>
  class WithSplitStreamingMethod_Search : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithSplitStreamingMethod_Search() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::SplitServerStreamingHandler< ::vrs::rpc::SearchRequest, ::vrs::rpc::SearchResult>(std::bind(&WithSplitStreamingMethod_Search<BaseClass>::StreamedSearch, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithSplitStreamingMethod_Search() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Search(::grpc::ServerContext* context, const ::vrs::rpc::SearchRequest* request, ::grpc::ServerWriter< ::vrs::rpc::SearchResult>* writer) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedSearch(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::vrs::rpc::SearchRequest,::vrs::rpc::SearchResult>* server_split_streamer) = 0;
  };
  typedef WithSplitStreamingMethod_Search<Service > SplitStreamedService;
  typedef WithSplitStreamingMethod_Search<WithStreamedUnaryMethod_ProcessVideo<WithStreamedUnaryMethod_Merge<Service > > > StreamedService;
};

class FaceRpc final {
 public:
  static constexpr char const* service_full_name() {
    return "vrs.rpc.FaceRpc";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    // 根据标注数据建立人脸分类器
    virtual ::grpc::Status BuildClassifer(::grpc::ClientContext* context, const ::vrs::rpc::Empty& request, ::vrs::rpc::Result* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::vrs::rpc::Result>> AsyncBuildClassifer(::grpc::ClientContext* context, const ::vrs::rpc::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::vrs::rpc::Result>>(AsyncBuildClassiferRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::vrs::rpc::Result>> PrepareAsyncBuildClassifer(::grpc::ClientContext* context, const ::vrs::rpc::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::vrs::rpc::Result>>(PrepareAsyncBuildClassiferRaw(context, request, cq));
    }
    // 在视频中检测人脸数据
    virtual ::grpc::Status DetectPersonsInVideo(::grpc::ClientContext* context, const ::vrs::rpc::DetectPersonsRequest& request, ::vrs::rpc::Result* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::vrs::rpc::Result>> AsyncDetectPersonsInVideo(::grpc::ClientContext* context, const ::vrs::rpc::DetectPersonsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::vrs::rpc::Result>>(AsyncDetectPersonsInVideoRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::vrs::rpc::Result>> PrepareAsyncDetectPersonsInVideo(::grpc::ClientContext* context, const ::vrs::rpc::DetectPersonsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::vrs::rpc::Result>>(PrepareAsyncDetectPersonsInVideoRaw(context, request, cq));
    }
    // 基于图像的人脸检测
    std::unique_ptr< ::grpc::ClientReaderInterface< ::vrs::rpc::DetectPersonInImgResult>> DetectPersonInImg(::grpc::ClientContext* context, const ::vrs::rpc::DetectPersonInImgRequest& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::vrs::rpc::DetectPersonInImgResult>>(DetectPersonInImgRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::vrs::rpc::DetectPersonInImgResult>> AsyncDetectPersonInImg(::grpc::ClientContext* context, const ::vrs::rpc::DetectPersonInImgRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::vrs::rpc::DetectPersonInImgResult>>(AsyncDetectPersonInImgRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::vrs::rpc::DetectPersonInImgResult>> PrepareAsyncDetectPersonInImg(::grpc::ClientContext* context, const ::vrs::rpc::DetectPersonInImgRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::vrs::rpc::DetectPersonInImgResult>>(PrepareAsyncDetectPersonInImgRaw(context, request, cq));
    }
  private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::vrs::rpc::Result>* AsyncBuildClassiferRaw(::grpc::ClientContext* context, const ::vrs::rpc::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::vrs::rpc::Result>* PrepareAsyncBuildClassiferRaw(::grpc::ClientContext* context, const ::vrs::rpc::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::vrs::rpc::Result>* AsyncDetectPersonsInVideoRaw(::grpc::ClientContext* context, const ::vrs::rpc::DetectPersonsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::vrs::rpc::Result>* PrepareAsyncDetectPersonsInVideoRaw(::grpc::ClientContext* context, const ::vrs::rpc::DetectPersonsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::vrs::rpc::DetectPersonInImgResult>* DetectPersonInImgRaw(::grpc::ClientContext* context, const ::vrs::rpc::DetectPersonInImgRequest& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::vrs::rpc::DetectPersonInImgResult>* AsyncDetectPersonInImgRaw(::grpc::ClientContext* context, const ::vrs::rpc::DetectPersonInImgRequest& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::vrs::rpc::DetectPersonInImgResult>* PrepareAsyncDetectPersonInImgRaw(::grpc::ClientContext* context, const ::vrs::rpc::DetectPersonInImgRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel);
    ::grpc::Status BuildClassifer(::grpc::ClientContext* context, const ::vrs::rpc::Empty& request, ::vrs::rpc::Result* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::vrs::rpc::Result>> AsyncBuildClassifer(::grpc::ClientContext* context, const ::vrs::rpc::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::vrs::rpc::Result>>(AsyncBuildClassiferRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::vrs::rpc::Result>> PrepareAsyncBuildClassifer(::grpc::ClientContext* context, const ::vrs::rpc::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::vrs::rpc::Result>>(PrepareAsyncBuildClassiferRaw(context, request, cq));
    }
    ::grpc::Status DetectPersonsInVideo(::grpc::ClientContext* context, const ::vrs::rpc::DetectPersonsRequest& request, ::vrs::rpc::Result* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::vrs::rpc::Result>> AsyncDetectPersonsInVideo(::grpc::ClientContext* context, const ::vrs::rpc::DetectPersonsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::vrs::rpc::Result>>(AsyncDetectPersonsInVideoRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::vrs::rpc::Result>> PrepareAsyncDetectPersonsInVideo(::grpc::ClientContext* context, const ::vrs::rpc::DetectPersonsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::vrs::rpc::Result>>(PrepareAsyncDetectPersonsInVideoRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::vrs::rpc::DetectPersonInImgResult>> DetectPersonInImg(::grpc::ClientContext* context, const ::vrs::rpc::DetectPersonInImgRequest& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::vrs::rpc::DetectPersonInImgResult>>(DetectPersonInImgRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::vrs::rpc::DetectPersonInImgResult>> AsyncDetectPersonInImg(::grpc::ClientContext* context, const ::vrs::rpc::DetectPersonInImgRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::vrs::rpc::DetectPersonInImgResult>>(AsyncDetectPersonInImgRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::vrs::rpc::DetectPersonInImgResult>> PrepareAsyncDetectPersonInImg(::grpc::ClientContext* context, const ::vrs::rpc::DetectPersonInImgRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::vrs::rpc::DetectPersonInImgResult>>(PrepareAsyncDetectPersonInImgRaw(context, request, cq));
    }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    ::grpc::ClientAsyncResponseReader< ::vrs::rpc::Result>* AsyncBuildClassiferRaw(::grpc::ClientContext* context, const ::vrs::rpc::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::vrs::rpc::Result>* PrepareAsyncBuildClassiferRaw(::grpc::ClientContext* context, const ::vrs::rpc::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::vrs::rpc::Result>* AsyncDetectPersonsInVideoRaw(::grpc::ClientContext* context, const ::vrs::rpc::DetectPersonsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::vrs::rpc::Result>* PrepareAsyncDetectPersonsInVideoRaw(::grpc::ClientContext* context, const ::vrs::rpc::DetectPersonsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::vrs::rpc::DetectPersonInImgResult>* DetectPersonInImgRaw(::grpc::ClientContext* context, const ::vrs::rpc::DetectPersonInImgRequest& request) override;
    ::grpc::ClientAsyncReader< ::vrs::rpc::DetectPersonInImgResult>* AsyncDetectPersonInImgRaw(::grpc::ClientContext* context, const ::vrs::rpc::DetectPersonInImgRequest& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::vrs::rpc::DetectPersonInImgResult>* PrepareAsyncDetectPersonInImgRaw(::grpc::ClientContext* context, const ::vrs::rpc::DetectPersonInImgRequest& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_BuildClassifer_;
    const ::grpc::internal::RpcMethod rpcmethod_DetectPersonsInVideo_;
    const ::grpc::internal::RpcMethod rpcmethod_DetectPersonInImg_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    // 根据标注数据建立人脸分类器
    virtual ::grpc::Status BuildClassifer(::grpc::ServerContext* context, const ::vrs::rpc::Empty* request, ::vrs::rpc::Result* response);
    // 在视频中检测人脸数据
    virtual ::grpc::Status DetectPersonsInVideo(::grpc::ServerContext* context, const ::vrs::rpc::DetectPersonsRequest* request, ::vrs::rpc::Result* response);
    // 基于图像的人脸检测
    virtual ::grpc::Status DetectPersonInImg(::grpc::ServerContext* context, const ::vrs::rpc::DetectPersonInImgRequest* request, ::grpc::ServerWriter< ::vrs::rpc::DetectPersonInImgResult>* writer);
  };
  template <class BaseClass>
  class WithAsyncMethod_BuildClassifer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_BuildClassifer() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_BuildClassifer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status BuildClassifer(::grpc::ServerContext* context, const ::vrs::rpc::Empty* request, ::vrs::rpc::Result* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestBuildClassifer(::grpc::ServerContext* context, ::vrs::rpc::Empty* request, ::grpc::ServerAsyncResponseWriter< ::vrs::rpc::Result>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_DetectPersonsInVideo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_DetectPersonsInVideo() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_DetectPersonsInVideo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DetectPersonsInVideo(::grpc::ServerContext* context, const ::vrs::rpc::DetectPersonsRequest* request, ::vrs::rpc::Result* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDetectPersonsInVideo(::grpc::ServerContext* context, ::vrs::rpc::DetectPersonsRequest* request, ::grpc::ServerAsyncResponseWriter< ::vrs::rpc::Result>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_DetectPersonInImg : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_DetectPersonInImg() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_DetectPersonInImg() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DetectPersonInImg(::grpc::ServerContext* context, const ::vrs::rpc::DetectPersonInImgRequest* request, ::grpc::ServerWriter< ::vrs::rpc::DetectPersonInImgResult>* writer) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDetectPersonInImg(::grpc::ServerContext* context, ::vrs::rpc::DetectPersonInImgRequest* request, ::grpc::ServerAsyncWriter< ::vrs::rpc::DetectPersonInImgResult>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(2, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_BuildClassifer<WithAsyncMethod_DetectPersonsInVideo<WithAsyncMethod_DetectPersonInImg<Service > > > AsyncService;
  template <class BaseClass>
  class WithGenericMethod_BuildClassifer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_BuildClassifer() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_BuildClassifer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status BuildClassifer(::grpc::ServerContext* context, const ::vrs::rpc::Empty* request, ::vrs::rpc::Result* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_DetectPersonsInVideo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_DetectPersonsInVideo() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_DetectPersonsInVideo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DetectPersonsInVideo(::grpc::ServerContext* context, const ::vrs::rpc::DetectPersonsRequest* request, ::vrs::rpc::Result* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_DetectPersonInImg : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_DetectPersonInImg() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_DetectPersonInImg() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DetectPersonInImg(::grpc::ServerContext* context, const ::vrs::rpc::DetectPersonInImgRequest* request, ::grpc::ServerWriter< ::vrs::rpc::DetectPersonInImgResult>* writer) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_BuildClassifer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_BuildClassifer() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler< ::vrs::rpc::Empty, ::vrs::rpc::Result>(std::bind(&WithStreamedUnaryMethod_BuildClassifer<BaseClass>::StreamedBuildClassifer, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_BuildClassifer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status BuildClassifer(::grpc::ServerContext* context, const ::vrs::rpc::Empty* request, ::vrs::rpc::Result* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedBuildClassifer(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::vrs::rpc::Empty,::vrs::rpc::Result>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_DetectPersonsInVideo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_DetectPersonsInVideo() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler< ::vrs::rpc::DetectPersonsRequest, ::vrs::rpc::Result>(std::bind(&WithStreamedUnaryMethod_DetectPersonsInVideo<BaseClass>::StreamedDetectPersonsInVideo, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_DetectPersonsInVideo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status DetectPersonsInVideo(::grpc::ServerContext* context, const ::vrs::rpc::DetectPersonsRequest* request, ::vrs::rpc::Result* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedDetectPersonsInVideo(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::vrs::rpc::DetectPersonsRequest,::vrs::rpc::Result>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_BuildClassifer<WithStreamedUnaryMethod_DetectPersonsInVideo<Service > > StreamedUnaryService;
  template <class BaseClass>
  class WithSplitStreamingMethod_DetectPersonInImg : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithSplitStreamingMethod_DetectPersonInImg() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::SplitServerStreamingHandler< ::vrs::rpc::DetectPersonInImgRequest, ::vrs::rpc::DetectPersonInImgResult>(std::bind(&WithSplitStreamingMethod_DetectPersonInImg<BaseClass>::StreamedDetectPersonInImg, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithSplitStreamingMethod_DetectPersonInImg() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status DetectPersonInImg(::grpc::ServerContext* context, const ::vrs::rpc::DetectPersonInImgRequest* request, ::grpc::ServerWriter< ::vrs::rpc::DetectPersonInImgResult>* writer) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedDetectPersonInImg(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::vrs::rpc::DetectPersonInImgRequest,::vrs::rpc::DetectPersonInImgResult>* server_split_streamer) = 0;
  };
  typedef WithSplitStreamingMethod_DetectPersonInImg<Service > SplitStreamedService;
  typedef WithStreamedUnaryMethod_BuildClassifer<WithStreamedUnaryMethod_DetectPersonsInVideo<WithSplitStreamingMethod_DetectPersonInImg<Service > > > StreamedService;
};

class ObjectRpc final {
 public:
  static constexpr char const* service_full_name() {
    return "vrs.rpc.ObjectRpc";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    std::unique_ptr< ::grpc::ClientReaderInterface< ::vrs::rpc::DetectObjectInImgResult>> DetectObjectInImg(::grpc::ClientContext* context, const ::vrs::rpc::DetectObjectInImgRequest& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::vrs::rpc::DetectObjectInImgResult>>(DetectObjectInImgRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::vrs::rpc::DetectObjectInImgResult>> AsyncDetectObjectInImg(::grpc::ClientContext* context, const ::vrs::rpc::DetectObjectInImgRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::vrs::rpc::DetectObjectInImgResult>>(AsyncDetectObjectInImgRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::vrs::rpc::DetectObjectInImgResult>> PrepareAsyncDetectObjectInImg(::grpc::ClientContext* context, const ::vrs::rpc::DetectObjectInImgRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::vrs::rpc::DetectObjectInImgResult>>(PrepareAsyncDetectObjectInImgRaw(context, request, cq));
    }
  private:
    virtual ::grpc::ClientReaderInterface< ::vrs::rpc::DetectObjectInImgResult>* DetectObjectInImgRaw(::grpc::ClientContext* context, const ::vrs::rpc::DetectObjectInImgRequest& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::vrs::rpc::DetectObjectInImgResult>* AsyncDetectObjectInImgRaw(::grpc::ClientContext* context, const ::vrs::rpc::DetectObjectInImgRequest& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::vrs::rpc::DetectObjectInImgResult>* PrepareAsyncDetectObjectInImgRaw(::grpc::ClientContext* context, const ::vrs::rpc::DetectObjectInImgRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel);
    std::unique_ptr< ::grpc::ClientReader< ::vrs::rpc::DetectObjectInImgResult>> DetectObjectInImg(::grpc::ClientContext* context, const ::vrs::rpc::DetectObjectInImgRequest& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::vrs::rpc::DetectObjectInImgResult>>(DetectObjectInImgRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::vrs::rpc::DetectObjectInImgResult>> AsyncDetectObjectInImg(::grpc::ClientContext* context, const ::vrs::rpc::DetectObjectInImgRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::vrs::rpc::DetectObjectInImgResult>>(AsyncDetectObjectInImgRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::vrs::rpc::DetectObjectInImgResult>> PrepareAsyncDetectObjectInImg(::grpc::ClientContext* context, const ::vrs::rpc::DetectObjectInImgRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::vrs::rpc::DetectObjectInImgResult>>(PrepareAsyncDetectObjectInImgRaw(context, request, cq));
    }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    ::grpc::ClientReader< ::vrs::rpc::DetectObjectInImgResult>* DetectObjectInImgRaw(::grpc::ClientContext* context, const ::vrs::rpc::DetectObjectInImgRequest& request) override;
    ::grpc::ClientAsyncReader< ::vrs::rpc::DetectObjectInImgResult>* AsyncDetectObjectInImgRaw(::grpc::ClientContext* context, const ::vrs::rpc::DetectObjectInImgRequest& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::vrs::rpc::DetectObjectInImgResult>* PrepareAsyncDetectObjectInImgRaw(::grpc::ClientContext* context, const ::vrs::rpc::DetectObjectInImgRequest& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_DetectObjectInImg_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    virtual ::grpc::Status DetectObjectInImg(::grpc::ServerContext* context, const ::vrs::rpc::DetectObjectInImgRequest* request, ::grpc::ServerWriter< ::vrs::rpc::DetectObjectInImgResult>* writer);
  };
  template <class BaseClass>
  class WithAsyncMethod_DetectObjectInImg : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_DetectObjectInImg() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_DetectObjectInImg() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DetectObjectInImg(::grpc::ServerContext* context, const ::vrs::rpc::DetectObjectInImgRequest* request, ::grpc::ServerWriter< ::vrs::rpc::DetectObjectInImgResult>* writer) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDetectObjectInImg(::grpc::ServerContext* context, ::vrs::rpc::DetectObjectInImgRequest* request, ::grpc::ServerAsyncWriter< ::vrs::rpc::DetectObjectInImgResult>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(0, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_DetectObjectInImg<Service > AsyncService;
  template <class BaseClass>
  class WithGenericMethod_DetectObjectInImg : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_DetectObjectInImg() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_DetectObjectInImg() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DetectObjectInImg(::grpc::ServerContext* context, const ::vrs::rpc::DetectObjectInImgRequest* request, ::grpc::ServerWriter< ::vrs::rpc::DetectObjectInImgResult>* writer) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  typedef Service StreamedUnaryService;
  template <class BaseClass>
  class WithSplitStreamingMethod_DetectObjectInImg : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithSplitStreamingMethod_DetectObjectInImg() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::SplitServerStreamingHandler< ::vrs::rpc::DetectObjectInImgRequest, ::vrs::rpc::DetectObjectInImgResult>(std::bind(&WithSplitStreamingMethod_DetectObjectInImg<BaseClass>::StreamedDetectObjectInImg, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithSplitStreamingMethod_DetectObjectInImg() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status DetectObjectInImg(::grpc::ServerContext* context, const ::vrs::rpc::DetectObjectInImgRequest* request, ::grpc::ServerWriter< ::vrs::rpc::DetectObjectInImgResult>* writer) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedDetectObjectInImg(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::vrs::rpc::DetectObjectInImgRequest,::vrs::rpc::DetectObjectInImgResult>* server_split_streamer) = 0;
  };
  typedef WithSplitStreamingMethod_DetectObjectInImg<Service > SplitStreamedService;
  typedef WithSplitStreamingMethod_DetectObjectInImg<Service > StreamedService;
};

}  // namespace rpc
}  // namespace vrs


#endif  // GRPC_vrs_2eproto__INCLUDED
